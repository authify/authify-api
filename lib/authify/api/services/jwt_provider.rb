module Authify
  module API
    module Services
      # A Sinatra App specifically for managing JWT tokens
      class JWTProvider < Service
        use Authify::API::Middleware::Metrics

        helpers Helpers::APIUser

        configure do
          set :protection, except: :http_origin
        end

        before do
          content_type 'application/json'

          begin
            unless request.get? || request.options?
              request.body.rewind
              @parsed_body = JSON.parse(request.body.read, symbolize_names: true)
            end
          rescue => e
            halt(400, { error: "Request must be valid JSON: #{e.message}" }.to_json)
          end
        end

        after do
          headers 'Access-Control-Allow-Origin' => '*',
                  'Access-Control-Allow-Methods' => %w[OPTIONS GET POST],
                  'Access-Control-Allow-Headers' => %w[
                    Origin
                    Accept
                    Accept-Encoding
                    Accept-Language
                    Access-Control-Request-Headers
                    Access-Control-Request-Method
                    Authorization
                    Connection
                    Content-Type
                    Host
                    Referer
                    User-Agent
                    X-Requested-With
                    X-Forwarded-For
                    X-XSRF-Token
                  ]
        end

        post '/token' do
          # For CLI / Typical API clients
          access = @parsed_body[:access_key] || @parsed_body[:'access-key']
          secret = @parsed_body[:secret_key] || @parsed_body[:'secret-key']
          # For Web UIs
          email = @parsed_body[:email]
          password = @parsed_body[:password]
          # For Trusted Delegates signing users in via omniauth
          omni_provider = @parsed_body[:provider]
          omni_uid = @parsed_body[:uid]
          # Allows injecting custom payload data
          custom_data = @parsed_body[:inject] || {}

          found_user = if access
                         Models::User.from_api_key(access, secret)
                       elsif remote_app
                         Models::User.from_identity(omni_provider, omni_uid)
                       elsif email
                         Models::User.from_email(email, password)
                       end

          if found_user
            update_current_user found_user
            Metrics.instance.increment('jwt.tokens.provided')
            found_user.token_refreshes = 0
            found_user.save
            { jwt: jwt_token(custom_data: custom_data) }.to_json
          else
            halt 401
          end
        end

        options '/token' do
          halt 200
        end

        # Provide information about the JWTs generated by the server
        get '/meta' do
          {
            algorithm: CONFIG[:jwt][:algorithm],
            issuer: CONFIG[:jwt][:issuer],
            expiration: CONFIG[:jwt][:expiration]
          }.to_json
        end

        options '/meta' do
          halt 200
        end

        # Provide access to the public ECDSA key
        get '/key' do
          {
            data: public_key.export
          }.to_json
        end

        options '/key' do
          halt 200
        end

        get '/verify' do
          process_token(@params[:token]).to_json
        end

        post '/verify' do
          process_token(@parsed_body[:token]).to_json
        end

        options '/verify' do
          halt 200
        end

        post '/refresh' do
          token_data = process_token(@parsed_body[:token])
          begin
            raise 'Invalid Token' unless token_data && token_data[:valid]
            payload = token_data[:payload]
            user = Models::User.find(payload['user']['uid'])

            refs = payload['meta'] && payload['meta']['refs'] ? payload['meta']['refs'] + 1 : 1
            raise 'Token Deprecated' unless user.token_refreshes == (refs - 1)
            new_meta = (payload['meta'] || {}).merge(refs: refs)
            user.token_refreshes = refs
            user.save

            Metrics.instance.increment('jwt.tokens.refreshed')
            {
              jwt: jwt_token(
                user: user,
                custom_data: payload[:custom],
                meta: new_meta
              )
            }.to_json
          rescue => e
            body({ errors: Array[e.message] }.to_json)
            halt 422
          end
        end

        options '/refresh' do
          halt 200
        end
      end
    end
  end
end
